## 并发安全和锁

多个请求或者goroutine操作同一块资源的时候，会发送数据的不一致

### 互斥锁与读写锁

1. **原子性**：把一个互斥量锁定为一个原子操作，这意味着操作系统（或pthread函数库）保证了如果一个线程锁定了一个互斥量，没有其他线程在同一时间可以成功锁定这个互斥量；
2. **唯一性**：如果一个线程锁定了一个互斥量，在它解除锁定之前，没有其他线程可以锁定这个互斥量
3. **非繁忙等待** : 如果一个线程已经锁定了一个互斥量，第二个线程又试图去锁定这个互斥量，则第二个线程将被挂起（不占用任何cpu资源），直到第一个线程解除对这个互斥量的锁定为止，第二个线程则被唤醒并继续执行，同时锁定这个互斥量。



```go
  var mu sync.Mutex
	mu.Lock()
	defer mu.Unlock()

  var rw sync.Mutex
  rw.Lock()
	defer rw.Unlock()
```

